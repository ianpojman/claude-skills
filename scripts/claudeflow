#!/bin/bash
# Continuous Local Execution Tool
# Runs Claude autonomously on multi-stage tasks with filesystem state persistence

set -euo pipefail

# Configuration
TASKS_DIR="$HOME/.claude/tasks"
ACTIVE_DIR="$TASKS_DIR/active"
COMPLETED_DIR="$TASKS_DIR/completed"
CHECKPOINTS_DIR="$TASKS_DIR/checkpoints"

# Colors
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Ensure directories exist
mkdir -p "$ACTIVE_DIR" "$COMPLETED_DIR" "$CHECKPOINTS_DIR"

usage() {
  cat <<EOF
Usage: continuous-local.sh [COMMAND] [OPTIONS]

Commands:
  start <task-id> [max-iterations]   Start or resume autonomous task execution
  create <task-id> <description>     Create new task interactively
  status [task-id]                   Show status of task(s)
  list                               List all active tasks
  stop <task-id>                     Mark task as stopped
  complete <task-id>                 Mark task as complete and archive
  context <task-id>                  View task context/history

Examples:
  # Create and start new task
  continuous-local.sh create refactor_auth "Refactor authentication module"
  continuous-local.sh start refactor_auth 10

  # Resume existing task
  continuous-local.sh start refactor_auth 5

  # Check status
  continuous-local.sh status refactor_auth
  continuous-local.sh list

EOF
  exit 1
}

create_task() {
  local task_id="$1"
  local description="${2:-}"
  local task_file="$ACTIVE_DIR/${task_id}.json"

  if [ -f "$task_file" ]; then
    echo -e "${YELLOW}âš ï¸  Task '$task_id' already exists${NC}"
    echo "Use 'continuous-local.sh start $task_id' to resume it"
    exit 1
  fi

  echo -e "${BLUE}Creating new task: $task_id${NC}"
  echo ""

  # Interactive setup if no description provided
  if [ -z "$description" ]; then
    read -p "Task description: " description
  fi

  read -p "Number of stages (default: 3): " total_stages
  total_stages=${total_stages:-3}

  read -p "Max iterations (default: 10): " max_iterations
  max_iterations=${max_iterations:-10}

  read -p "Validation command (optional, e.g., 'npm test'): " validation_cmd
  validation_cmd=${validation_cmd:-true}

  read -p "Link to TaskFlow issue ID (optional, e.g., REF-001): " taskflow_issue

  # Build stages array
  stages_json="["
  for i in $(seq 1 "$total_stages"); do
    read -p "Stage $i name: " stage_name
    stages_json+='{"id": '$i', "name": "'"$stage_name"'", "status": "pending"}'
    [ "$i" -lt "$total_stages" ] && stages_json+=","
  done
  stages_json+="]"

  # Create task state file
  cat > "$task_file" <<EOF
{
  "task_id": "$task_id",
  "description": "$description",
  "taskflow_issue": "$taskflow_issue",
  "created_at": "$(date -u +%Y-%m-%dT%H:%M:%SZ)",
  "updated_at": "$(date -u +%Y-%m-%dT%H:%M:%SZ)",
  "status": "created",
  "max_iterations": $max_iterations,
  "current_iteration": 0,
  "current_stage": 1,
  "total_stages": $total_stages,
  "stages": $stages_json,
  "validation_command": "$validation_cmd",
  "context_file": "$CHECKPOINTS_DIR/${task_id}_context.md",
  "next_action": "Begin stage 1"
}
EOF

  # Create context file
  cat > "$CHECKPOINTS_DIR/${task_id}_context.md" <<EOF
# Task Context: $task_id

**Description**: $description
**Created**: $(date)
**TaskFlow Issue**: ${taskflow_issue:-N/A}

## Iteration 0 - Initial State

Task initialized and ready to begin.

**Stages**:
EOF

  for i in $(seq 1 "$total_stages"); do
    stage_name=$(echo "$stages_json" | jq -r ".[$((i-1))].name")
    echo "$i. $stage_name" >> "$CHECKPOINTS_DIR/${task_id}_context.md"
  done

  echo -e "\n---\n" >> "$CHECKPOINTS_DIR/${task_id}_context.md"

  echo -e "${GREEN}âœ… Task created: $task_file${NC}"
  echo ""
  echo "Next steps:"
  echo "  1. Review/edit task file: $task_file"
  echo "  2. Start execution: continuous-local.sh start $task_id"

  # Offer to create TaskFlow issue if not provided
  if [ -z "$taskflow_issue" ] && command -v taskflow &>/dev/null; then
    read -p "Create TaskFlow issue now? [y/N]: " create_tf
    if [[ "$create_tf" =~ ^[Yy]$ ]]; then
      echo "Run: taskflow new <ID> \"$description\""
    fi
  fi
}

show_status() {
  local task_id="${1:-}"

  if [ -n "$task_id" ]; then
    # Show specific task
    local task_file="$ACTIVE_DIR/${task_id}.json"
    if [ ! -f "$task_file" ]; then
      echo -e "${RED}âŒ Task not found: $task_id${NC}"
      exit 1
    fi

    echo -e "${BLUE}â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”${NC}"
    echo -e "${BLUE}Task: $task_id${NC}"
    echo -e "${BLUE}â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”${NC}"

    jq -r '"
Description: \(.description)
Status: \(.status)
Progress: Stage \(.current_stage)/\(.total_stages) | Iteration \(.current_iteration)/\(.max_iterations)
TaskFlow: \(.taskflow_issue // "N/A")
Created: \(.created_at)
Updated: \(.updated_at)
Next Action: \(.next_action)
"' "$task_file"

    echo "Stages:"
    jq -r '.stages[] | "  \(.id). [\(.status)] \(.name)"' "$task_file"

  else
    # Show all tasks
    echo -e "${BLUE}Active Tasks:${NC}"
    echo ""

    if ! ls "$ACTIVE_DIR"/*.json &>/dev/null; then
      echo "No active tasks."
      return
    fi

    for task_file in "$ACTIVE_DIR"/*.json; do
      task_id=$(basename "$task_file" .json)
      status=$(jq -r '.status' "$task_file")
      stage=$(jq -r '.current_stage' "$task_file")
      total=$(jq -r '.total_stages' "$task_file")
      desc=$(jq -r '.description' "$task_file")

      case "$status" in
        completed) status_icon="${GREEN}âœ…${NC}" ;;
        in_progress) status_icon="${YELLOW}â³${NC}" ;;
        stopped) status_icon="${RED}ðŸ›‘${NC}" ;;
        *) status_icon="ðŸ“‹" ;;
      esac

      echo -e "$status_icon $task_id: $desc (Stage $stage/$total)"
    done
  fi
}

start_execution() {
  local task_id="$1"
  local max_iterations="${2:-}"
  local task_file="$ACTIVE_DIR/${task_id}.json"

  if [ ! -f "$task_file" ]; then
    echo -e "${RED}âŒ Task not found: $task_id${NC}"
    echo "Create it first: continuous-local.sh create $task_id"
    exit 1
  fi

  # Override max iterations if provided
  if [ -n "$max_iterations" ]; then
    jq --arg max "$max_iterations" '.max_iterations = ($max|tonumber)' "$task_file" > "${task_file}.tmp"
    mv "${task_file}.tmp" "$task_file"
  fi

  local context_file=$(jq -r '.context_file' "$task_file")
  local current_iteration=$(jq -r '.current_iteration' "$task_file")
  local max_iter=$(jq -r '.max_iterations' "$task_file")

  echo -e "${BLUE}â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”${NC}"
  echo -e "${BLUE}Starting Continuous Execution: $task_id${NC}"
  echo -e "${BLUE}â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”${NC}"
  echo ""

  show_status "$task_id"
  echo ""

  read -p "Start execution? [Y/n]: " confirm
  if [[ "$confirm" =~ ^[Nn]$ ]]; then
    echo "Cancelled."
    exit 0
  fi

  # Update status to in_progress
  jq '.status = "in_progress" | .updated_at = "'$(date -u +%Y-%m-%dT%H:%M:%SZ)'"' "$task_file" > "${task_file}.tmp"
  mv "${task_file}.tmp" "$task_file"

  # Main execution loop
  for i in $(seq $((current_iteration + 1)) "$max_iter"); do
    echo ""
    echo -e "${BLUE}â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”${NC}"
    echo -e "${BLUE}ðŸ”„ Iteration $i/$max_iter${NC}"
    echo -e "${BLUE}â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”${NC}"

    # Update iteration count
    jq --arg i "$i" '.current_iteration = ($i|tonumber) | .updated_at = "'$(date -u +%Y-%m-%dT%H:%M:%SZ)'"' "$task_file" > "${task_file}.tmp"
    mv "${task_file}.tmp" "$task_file"

    # Read current state
    local current_stage=$(jq -r '.current_stage' "$task_file")
    local total_stages=$(jq -r '.total_stages' "$task_file")
    local next_action=$(jq -r '.next_action' "$task_file")
    local description=$(jq -r '.description' "$task_file")
    local validation_cmd=$(jq -r '.validation_command // "true"' "$task_file")

    echo "Stage: $current_stage/$total_stages"
    echo "Next: $next_action"
    echo ""

    # Build prompt for Claude
    local prompt="You are working on a multi-stage autonomous task using the continuous-local execution pattern.

**IMPORTANT INSTRUCTIONS**:
1. This is AUTONOMOUS execution - do NOT ask for permission between stages
2. You MUST update the task state file after completing work
3. You MUST update the context file with what you did and what's next
4. Work through stages sequentially and automatically
5. Use TaskFlow integration to document progress

**Task State File**: $task_file
**Context History File**: $context_file

**Current Status**:
- Task: $description
- Iteration: $i/$max_iter
- Stage: $current_stage/$total_stages
- Next Action: $next_action

**Previous Context**:
\`\`\`
$(tail -n 100 "$context_file")
\`\`\`

**Your Task**:
1. Read the full task state: cat $task_file
2. Execute the next action for the current stage
3. Append to context file what you did:
   echo \"## Iteration $i - [what you did]
   **Date**: \$(date)
   **Actions**: [list of actions]
   **Issues**: [any problems encountered]
   **Next**: [what should happen next]
   ---\" >> $context_file

4. Update task state with jq:
   - If stage complete: update stage status to 'completed', increment current_stage
   - Update next_action with what should happen next
   - Update updated_at timestamp
   - **Sync to TaskFlow**: If stage complete AND taskflow_issue exists, run:
     taskflow capture \"$task_id: Stage \$stage completed - [brief summary]\"

5. If validation command exists, run it: $validation_cmd

6. If all stages complete, update status to 'completed'

**TaskFlow Integration (Hybrid Approach)**:
ClaudeFlow manages detailed iteration state, but automatically syncs to TaskFlow:

- Stage completions â†’ taskflow capture
- Major discoveries/blockers â†’ taskflow capture
- Task completion â†’ taskflow capture with full summary
- Read BACKLOG for taskflow_issue context

Example TaskFlow sync:
\`\`\`bash
# When stage completes
if [ taskflow_issue exists ]; then
  taskflow capture \"\$task_id Stage \$stage_num complete: [what was done]\"
fi

# When task completes
taskflow capture \"\$task_id COMPLETE: [summary of all stages]\"
\`\`\`

This gives you:
- ClaudeFlow: Detailed iteration-by-iteration state
- TaskFlow: High-level milestone documentation

**Example state update**:
\`\`\`bash
# Mark current stage complete and move to next
jq '.stages[$((current_stage - 1))].status = \"completed\" |
    .current_stage = $((current_stage + 1)) |
    .next_action = \"[description of next stage]\" |
    .updated_at = \"'$(date -u +%Y-%m-%dT%H:%M:%SZ)'\"' $task_file > ${task_file}.tmp && mv ${task_file}.tmp $task_file

# If all stages done
jq '.status = \"completed\"' $task_file > ${task_file}.tmp && mv ${task_file}.tmp $task_file
\`\`\`

Proceed autonomously. Execute the next action now."

    # Write prompt to temp file
    local prompt_file="/tmp/continuous_local_prompt_${task_id}.txt"
    echo "$prompt" > "$prompt_file"

    echo -e "${YELLOW}Invoking Claude...${NC}"
    echo ""

    # Invoke Claude
    # Note: Adjust this command based on your Claude Code setup
    # This assumes you can pipe a prompt to claude
    if command -v claude &>/dev/null; then
      cat "$prompt_file" | claude
    elif command -v claude-code &>/dev/null; then
      cat "$prompt_file" | claude-code
    else
      echo -e "${RED}âŒ Claude command not found. Please invoke Claude manually with:${NC}"
      echo "cat $prompt_file | your-claude-command"
      read -p "Press enter when done..."
    fi

    # Check if task completed
    local status=$(jq -r '.status // "in_progress"' "$task_file")
    if [ "$status" = "completed" ]; then
      echo ""
      echo -e "${GREEN}âœ… Task completed!${NC}"

      # Sync to TaskFlow if linked
      local taskflow_issue=$(jq -r '.taskflow_issue // ""' "$task_file")
      if [ -n "$taskflow_issue" ] && command -v taskflow &>/dev/null; then
        echo ""
        echo -e "${BLUE}ðŸ“ Syncing completion to TaskFlow...${NC}"

        # Generate summary from stages
        local summary=$(jq -r '.stages[] | "- âœ… \(.name)"' "$task_file" | tr '\n' ' ')
        local description=$(jq -r '.description' "$task_file")

        # Capture to TaskFlow
        taskflow capture "$task_id COMPLETE: $description. Stages: $summary" 2>/dev/null || echo "âš ï¸  TaskFlow capture failed (non-fatal)"
      fi

      # Move to completed
      mv "$task_file" "$COMPLETED_DIR/"

      # Show final summary
      echo ""
      echo "Summary:"
      jq -r '.stages[] | "  âœ… \(.name)"' "$COMPLETED_DIR/$(basename "$task_file")"

      echo ""
      echo "Context history: $context_file"

      exit 0
    fi

    # Run validation if specified
    if [ "$validation_cmd" != "true" ]; then
      echo ""
      echo -e "${YELLOW}Running validation: $validation_cmd${NC}"

      if eval "$validation_cmd"; then
        echo -e "${GREEN}âœ… Validation passed${NC}"
        jq '.last_validation = {"timestamp": "'$(date -u +%Y-%m-%dT%H:%M:%SZ)'", "status": "passed"}' "$task_file" > "${task_file}.tmp"
        mv "${task_file}.tmp" "$task_file"
      else
        echo -e "${RED}âŒ Validation failed${NC}"
        jq '.last_validation = {"timestamp": "'$(date -u +%Y-%m-%dT%H:%M:%SZ)'", "status": "failed"}' "$task_file" > "${task_file}.tmp"
        mv "${task_file}.tmp" "$task_file"

        echo -e "\n## Iteration $i - Validation Failed\n$(date)\nValidation command failed: $validation_cmd\n---\n" >> "$context_file"

        # Continue to next iteration (Claude will see failure in context)
      fi
    fi

    # Brief pause
    echo ""
    echo -e "${BLUE}Waiting 3 seconds before next iteration...${NC}"
    sleep 3
  done

  echo ""
  echo -e "${YELLOW}âš ï¸  Max iterations ($max_iter) reached${NC}"
  echo "Task still in progress. Review state at: $task_file"
  echo ""
  echo "Options:"
  echo "  - Resume: continuous-local.sh start $task_id [more-iterations]"
  echo "  - View context: continuous-local.sh context $task_id"
  echo "  - Check status: continuous-local.sh status $task_id"
}

view_context() {
  local task_id="$1"
  local task_file="$ACTIVE_DIR/${task_id}.json"

  if [ ! -f "$task_file" ]; then
    # Try completed
    task_file="$COMPLETED_DIR/${task_id}.json"
  fi

  if [ ! -f "$task_file" ]; then
    echo -e "${RED}âŒ Task not found: $task_id${NC}"
    exit 1
  fi

  local context_file=$(jq -r '.context_file' "$task_file")

  if [ ! -f "$context_file" ]; then
    echo -e "${RED}âŒ Context file not found: $context_file${NC}"
    exit 1
  fi

  echo -e "${BLUE}Context for task: $task_id${NC}"
  echo -e "${BLUE}â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”${NC}"
  echo ""
  cat "$context_file"
}

mark_complete() {
  local task_id="$1"
  local task_file="$ACTIVE_DIR/${task_id}.json"

  if [ ! -f "$task_file" ]; then
    echo -e "${RED}âŒ Task not found: $task_id${NC}"
    exit 1
  fi

  echo -e "${BLUE}Marking task as complete: $task_id${NC}"

  jq '.status = "completed" | .updated_at = "'$(date -u +%Y-%m-%dT%H:%M:%SZ)'"' "$task_file" > "${task_file}.tmp"
  mv "${task_file}.tmp" "$task_file"

  mv "$task_file" "$COMPLETED_DIR/"

  echo -e "${GREEN}âœ… Task moved to completed${NC}"
  echo "File: $COMPLETED_DIR/${task_id}.json"
}

# Main command router
case "${1:-}" in
  create)
    [ -z "${2:-}" ] && usage
    create_task "$2" "${3:-}"
    ;;
  start)
    [ -z "${2:-}" ] && usage
    start_execution "$2" "${3:-}"
    ;;
  status)
    show_status "${2:-}"
    ;;
  list)
    show_status
    ;;
  context)
    [ -z "${2:-}" ] && usage
    view_context "$2"
    ;;
  complete)
    [ -z "${2:-}" ] && usage
    mark_complete "$2"
    ;;
  *)
    usage
    ;;
esac
